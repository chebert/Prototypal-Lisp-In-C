#include "tag.h"

#include <assert.h>
#include <stdio.h>

struct Input {
  const u8 *source;
  u64 byte_position;
};

typedef void *Parser;

u8 ReadInput(struct Input *input);
struct Input SaveInput(struct Input *input);
struct Input RestoreInput(struct Input saved, struct Input *input);

Parser Satisfies(b64 (*predicate)(int character));
Parser Sequence(Parser first, Parser second);
Parser OneOf(Parser first, Parser second);
Parser Many(Parser parser);
Parser OneOrMore(Parser parser);

Parser DiscardFirst(Parser first, Parser second);
Parser DiscardSecond(Parser first, Parser second);

Parser ParseObject();
Parser ParseInteger();
Parser ParseNil();
Parser ParseList();

struct ParseResult {
  union {
    u8 character;
    u8 *string;
    Object object;
  } as;
};
struct ParserSatisfies {
  b64 (*satisfies)(int character);
  const char *description;
};
struct ParserSequence {
  Parser first;
  Parser second;
};
struct ParserOneOf {
  Parser first;
  Parser second;
};

struct ParseResult ParseFailure(const char *parser_description);
struct ParseResult ParseSequenceFailure(struct ParserSequence *parser, struct ParseResult failure);
struct ParseResult ParseOneOfFailure(struct ParserOneOf *parser, struct ParseResult first_failure, struct ParseResult second_failure);

struct ParseResult Parse(Parser parser, struct Input *input);

struct ParseResult ParseSatisifies(struct ParserSatisfies *parser, struct Input *input);
struct ParseResult ParseSequence(struct ParserSequence *parser, struct Input *input);
struct ParseResult ParseOneOf(struct ParserOneOf *parser, struct Input *input);

struct ParseResult ParseSequenceResult(struct ParseResult first_result, struct ParseResult second_result);
struct ParseResult ParseSuccessCharacter(u8 character);
struct ParseResult ParseSuccessString(const u8 *string);

b64 IsParseFailure(struct ParseResult result);
b64 IsDiscardFirst(struct ParserSequence *parser);
b64 IsDiscardSecond(struct ParserSequence *parser);

b64 IsParseResultCharacter(struct ParseResult result);
b64 IsParseResultString(struct ParseResult result);
b64 IsParseResultObject(struct ParseResult result);

const u8 *AppendCharacters(u8 c1, u8 c2);
const u8 *PrependCharacter(u8 c, const u8 *string);
const u8 *AppendCharacter(const u8 *string, u8 c);
const u8 *AppendStrings(const u8 *string1, const u8 *string2);

struct ParseResult ParseSatisifies(struct ParserSatisfies *parser, struct Input *input) {
  int next = ReadInput(input);
  if (EOF == next || !parser->satisfies(next)) {
    return ParseFailure(parser->description);
  } else {
    return ParseSuccessCharacter(next);
  }
}

struct ParseResult ParseSequence(struct ParserSequence *parser, struct Input *input) {
  // Save the input, and restore it if there is a parse failure.
  struct Input saved = SaveInput(input);

  // Try parsing the first_result
  struct ParseResult first_result = Parse(parser->first, input);
  if (IsParseFailure(first_result)) {
    // If we fail, restore input and return the failure.
    RestoreInput(saved, input);
    return ParseSequenceFailure(parser, first_result);
  } else {
    // If we succeed, try the second parser
    struct ParseResult second_result = Parse(parser->second, input);
    if (IsParseFailure(second_result)) {
      RestoreInput(saved, input);
      return ParseSequenceFailure(parser, second_result);
    } else {
      if (IsDiscardFirst(parser)) {
        return second_result;
      } else if (IsDiscardSecond(parser)) {
        return first_result;
      } else {
        return ParseSequenceResult(first_result, second_result);
      }
    }
  }
}

struct ParseResult ParseOneOf(struct ParserOneOf *parser, struct Input *input) {
  struct Input saved = SaveInput(input);

  struct ParseResult first_result = Parse(parser->first, input);
  if (IsParseFailure(first_result)) {
    // If we fail, restore input and try the second
    RestoreInput(saved, input);
    struct ParseResult second_result = Parse(parser->second, input);
    if (IsParseFailure(second_result)) {
      RestoreInput(saved, input);
      return ParseOneOfFailure(parser, first_result, second_result);
    } else {
      return second_result;
    }
  } else {
    return first_result;
  }
}

struct ParseResult ParseSequenceFailure(struct ParserSequence *parser, struct ParseResult failure) {
  return failure;
}
struct ParseResult ParseOneOfFailure(struct ParserOneOf *parser, struct ParseResult first_failure, struct ParseResult second_failure) {
  return second_failure;
}
struct ParseResult ParseSequenceResult(struct ParseResult first_result, struct ParseResult second_result) {
  if (IsParseResultCharacter(first_result)) {
    if (IsParseResultCharacter(second_result)) {
      return ParseSuccessString(AppendCharacters(first_result.as.character, second_result.as.character));
    } else if (IsParseResultString(second_result)) {
      return ParseSuccessString(PrependCharacter(first_result.as.character, second_result.as.string));
    } else {
      assert(!"Don't know how to combine a char with an object");
    }
  } else if (IsParseResultString(first_result)) {
    if (IsParseResultCharacter(second_result)) {
      return ParseSuccessString(AppendCharacter(first_result.as.string, second_result.as.character));
    } else if (IsParseResultString(second_result)) {
      return ParseSuccessString(AppendStrings(first_result.as.string, second_result.as.string));
    } else {
      assert(!"Don't know how to combine a string with an object");
    }
  } else if (IsParseResultObject(first_result)) {
    if (IsParseResultCharacter(second_result)) {
      assert(!"Don't know how to combine an object with a character");
    } else if (IsParseResultString(second_result)) {
      assert(!"Don't know how to combine an object with a string");
    } else {
      assert(!"TODO: combine object with object in sequence");
    }
  }
}


u8 ReadInput(struct Input *input) {
  return input->source[input->byte_position++];
}
struct Input SaveInput(struct Input *input) {
  return *input;
}
struct Input RestoreInput(struct Input saved, struct Input *input) {
  *input = saved;
}

#if 0
Parser ParseObject() {
  return Sequence(
      Many(ParseWhitespace()),
      Sequence(
        OneOf(
          ParsePrimitive(),
          ParseListLike(),
          ParseSymbolicQuote()),
        Many(ParseWhitespace())));
}

Parser ParsePrimitive() {
  return OneOf(
      ParseNumber(),
      OneOf(
        ParseBoolean(),
        ParseNil()));
}

Parser ParseNumber() {
  return OneOf(
      ParseInteger(),
      OneOf(
        ParseReal64(),
        ParseReal32()));
}

Parser ParseBoolean() {
  return OneOf(
      ParseTrue(),
      ParseFalse());
}

Parser ParseInteger() {
  return Sequence(
      Optional(ParseNumberSign()),
      OneOrMore(ParseDigit()));
}

Parser ParseReal32() {
  return ParseFloatingPoint(ParseReal32ExponentMarker());
}

Parser ParseReal64() {
  return ParseFloatingPoint(ParseReal64ExponentMarker());
}

Parser ParseFloatingPoint(Parser exponent_marker_matcher) {
  return Sequence(
      Optional(ParseNumberSign()),
      OneOf(
        Sequence(
          ParseAny(ParseDigit()),
          Sequence(
            ParseFractionalPart(),
            Optional(ParseExponent(exponent_marker_matcher)))),
        Sequence(
          OneOrMore(ParseDigit()),
          Sequence(
            Optional(ParseFractionalPart()),
            ParseExponent(exponent_marker_matcher)))));
}

Parser ParseFractionalPart() {
  return Sequence(ParseDecimalPoint(), ParseAny(ParseDigit()));
}

Parser ParseExponent(Parser expoent_marker_matcher) {
  return Sequence(exponent_marker_matcher, ParseInteger());
}

Parser ParseDecimalPoint() { return Satisfies(IsDecimalPoint); }
Parser ParseDigit() { return Satisfies(IsDigit); }
Parser ParseReal32ExponentMarker() { return Satisfies(IsReal32ExponentMarker); }
Parser ParseReal64ExponentMarker() { return Satisfies(IsReal64ExponentMarker); }
Parser ParseStringQuote() { return Satisfies(IsStringQuote); }
Parser ParseEscapeCharacter() { return Satisfies(IsEscapeCharacter); }
Parser ParseAnyCharacter() { return Satisfies(IsAnyCharacter); }
Parser ParseFirstSymbolCharacter() { return Satisfies(IsFirstSymbolCharacter); }
Parser ParseRestSymbolCharacter() { return Satisfies(IsRestSymbolCharacter); }
Parser ParseOpenList() { return Satisfies(IsOpenList); }
Parser ParseCloseList() { return Satisfies(IsCloseList); }
Parser ParsePairSeparator() { return Satisfies(IsPairSeparator); }

Parser ParseTrue() { return ParseConcatenation("#t"); }
Parser ParseFalse() { return ParseConcatenation("#f"); }

Parser ParseString() {
  return Sequence(
      ParseStringQuote(),
      Sequence(
        OneOf(
          ParseStringCharacter(),
          ParseEscapeSequence()),
        ParseStringQuote()));
}

Parser ParseEscapeSequence() {
  return Sequence(
      ParseEscapeCharacter(),
      ParseAnyCharacter());
}

Parser ParseSymbol() {
  return Sequence(
      ParseFirstSymbolCharacter(),
      Many(ParseRestSymbolCharacter()));
}

Parser ParseNil() {
  return Sequence(
      ParseOpenList(),
      Sequence(
        Many(ParseWhitespace()),
        ParseCloseList()));
}

Parser ParseListLike() {
  return OneOf(ParseList(), ParseDottedList());
}

Parser ParseDottedList() {
  // open-list object+ pair-separator object close-list
  // (         a b c   .              d      )
  // (a b c . d)
  return Sequence(
      ParseOpenList(),
      Sequence(
        OneOrMore(ParseObject()),
        Sequence(
          ParsePairSeparator(),
          Sequence(
            ParseObject(),
            ParseCloseList()))));
}

Parser ParseList() {
  // open-list object+ close-list
  // (         a b c   )
  return Sequence(
      ParseOpenList(),
      Sequence(
        OneOrMore(ParseObject()),
        ParseCloseList()));
}

Parser ParseSymbolicQuote() {
  // symbolic-quote object
  // '              (a b c)
  // '(a b c)
  return Sequence(
      ParseSymbolicQuote(),
      ParseObject());
}

Parser ParseStringLike() {
  return OneOf(ParseSymbol(), ParseString());
}
#endif
